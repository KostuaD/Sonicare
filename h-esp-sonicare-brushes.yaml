# Philips Sonicare BLE controller for ESPHome
# (Updated: move on_boot under `esphome:` to avoid "Component not found: on_boot" error)
#
# Explanation of change:
# The previous placement of `on_boot:` at the very top-level caused ESPHome to treat it
# as a component name, producing "Component not found: on_boot". Placing `on_boot:` as a
# child of the `esphome:` section is the correct form for this ESPHome version.
#
# I only moved the on_boot block under the existing `esphome:` section and left the
# rest of your configuration intact. The on_boot actions ensure GPIO3 is driven LOW
# (enable RF switch control) and GPIO14 is set HIGH (external antenna) by default,
# and the global variable is updated accordingly.
#
substitutions:
  devicename: h-esp-sonicare-brushes
  friendly_name: h_esp_sonicare_brushes
  entity_name: Controller
  brush_1_name: Brush_1
  brush_1_mac: !secret brush_1_mac
  brush_2_name: Brush_2
  brush_2_mac: !secret brush_2_mac

esphome:
  name: ${devicename}
  friendly_name: ${friendly_name}
  comment: "Philips Sonicare BLE"

  on_boot:
    priority: -100.0
    then:
      # Ensure RF switch control enabled: set GPIO3 = LOW
      - output.turn_off: wifi_enable_output
      - delay: 50ms

      # Set default antenna: external (GPIO14 = HIGH)
      - output.turn_on: wifi_antenna_output
      - delay: 50ms

      # Persist state: update global (already done elsewhere, but safe to set here)
      - globals.set:
          id: wifi_antenna_state
          value: 'true'

      # IMPORTANT: update the template switch entity state in Home Assistant
      # so the UI reflects the current (physical) state. Because the switch is
      # optimistic, calling switch.turn_on ensures HA shows it ON.
      - switch.turn_on: wifi_antenna_switch
      
# Hardware / platform
esp32:
  board: esp32-c6-devkitc-1
  flash_size: 4MB
  framework:
    type: esp-idf

logger:
  level: INFO

# Home Assistant API with encryption
api:
  encryption:
    key: !secret encryption_key

# Over-the-air updates protected by password
ota:
  - platform: esphome
    password: !secret ota_password

# Wi-Fi configuration and fallback access point
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  ap:
    ssid: "Sonicare Fallback Hotspot"
    password: !secret ssid_password

captive_portal: {}

# Lightweight local web server for basic status pages (port 80).
web_server:
  port: 80

# BLE tracker and advertisement filtering
esp32_ble_tracker:
  on_ble_advertise:
    - lambda: |-
        // Helper: format raw Bluetooth address bytes into uppercase colon-separated MAC
        auto mac_from_bytes = [&](const uint8_t *addr)->std::string {
          char buf[18];
          snprintf(buf, sizeof(buf), "%02X:%02X:%02X:%02X:%02X:%02X",
                   addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
          return std::string(buf);
        };

        const uint8_t *addr = x.address();
        if (addr == nullptr) {
          ESP_LOGV("ble_filter", "Advertise with null address");
          return;
        }
        std::string mac = mac_from_bytes(addr);

        if (mac == std::string("${brush_1_mac}") || mac == std::string("${brush_2_mac}")) {
          ESP_LOGD("ble_filter", "Seen target device: %s", mac.c_str());
        } else {
          ESP_LOGV("ble_filter", "Ignoring device: %s", mac.c_str());
          return;
        }

# Local package usage for each brush instance
packages:
  brush_1:
    url: https://github.com/KostuaD/Sonicare
    files:
      - path: packages/sonicare.yaml
        vars:
          mac: ${brush_1_mac}
          id: ${brush_1_name}
          name: ${brush_1_name}

  brush_2:
    url: https://github.com/KostuaD/Sonicare
    files:
      - path: packages/sonicare.yaml
        vars:
          mac: ${brush_2_mac}
          id: ${brush_2_name}
          name: ${brush_2_name}

# System controls
button:
  - platform: restart
    icon: mdi:power-cycle
    name: ${entity_name} ESP Reboot
    entity_category: diagnostic

# Antenna control block
output:
  - platform: gpio
    id: wifi_enable_output
    pin:
      number: 3
      inverted: false

  - platform: gpio
    id: wifi_antenna_output
    pin:
      number: 14
      inverted: false

globals:
  - id: wifi_antenna_state
    type: bool
    restore_value: true
    initial_value: 'true'  # true = external antenna (GPIO14 HIGH) by default on boot

switch:
  - platform: template
    name: "WiFi Antenna - External"
    id: wifi_antenna_switch
    optimistic: true
    turn_on_action:
      - output.turn_off: wifi_enable_output
      - delay: 50ms
      - output.turn_on: wifi_antenna_output
      - globals.set:
          id: wifi_antenna_state
          value: 'true'
    turn_off_action:
      - output.turn_off: wifi_enable_output
      - delay: 50ms
      - output.turn_off: wifi_antenna_output
      - globals.set:
          id: wifi_antenna_state
          value: 'false'

binary_sensor:
  - platform: template
    name: "WiFi Antenna Selected (External)"
    id: wifi_antenna_selected
    lambda: |-
      return id(wifi_antenna_state);
    device_class: connectivity

# Standard sensors & text sensors
text_sensor:
  - platform: wifi_info
    ip_address:
      name: "IP Address"

  - platform: template
    name: "Uptime"
    id: uptime_${friendly_name}
    icon: mdi:clock-start

sensor:
  - platform: wifi_signal
    name: "WiFi Signal dB"
    id: wifi_signal_db
    update_interval: 60s
    entity_category: diagnostic

  - platform: template
    name: "WiFi Signal Percent"
    id: wifi_signal_percent
    update_interval: 60s
    lambda: |-
      float db = id(wifi_signal_db).state;
      if (!std::isfinite(db)) return 0.0;
      float pct = fmin(fmax(2.0 * (db + 100.0), 0.0), 100.0);
      return pct;
    unit_of_measurement: "%"
    icon: "mdi:wifi"
    entity_category: diagnostic

  - platform: uptime
    name: "Uptime Sensor"
    id: uptime_sensor
    update_interval: 60s
    internal: true
    on_raw_value:
      then:
        - text_sensor.template.publish:
            id: uptime_${friendly_name}
            state: !lambda |-
              if (!std::isfinite(x)) return std::string("0s");
              int seconds = (int)round(x);
              int days = seconds / (24 * 3600);
              seconds = seconds % (24 * 3600);
              int hours = seconds / 3600;
              seconds = seconds % 3600;
              int minutes = seconds / 60;

              std::string result = "";
              if (days) result += std::to_string(days) + "d ";
              if (hours) result += std::to_string(hours) + "h ";
              if (minutes || (!days && !hours)) result += std::to_string(minutes) + "m";

              return result;

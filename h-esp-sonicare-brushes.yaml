# Philips Sonicare BLE controller for ESPHome
# Description:
#   This configuration builds an ESPHome device that tracks Philips Sonicare toothbrushes
#   over BLE and exposes their data to Home Assistant. It runs on an ESP32-C6 board,
#   includes Wi‑Fi, OTA, API, a small web server, and uses a local reusable package
#   (esphome/packages/sonicare.yaml) for each brush instance. The esp32_ble_tracker
#   component uses an on_ble_advertise lambda to filter BLE advertisements by MAC.
#

substitutions:
  # Device and entity naming substitutions used throughout the config
  devicename: h-esp-sonicare-brushes
  friendly_name: h_esp_sonicare_brushes
  entity_name: Controller
  brush_1_name: Brush_1
  brush_1_mac: !secret brush_1_mac
  brush_2_name: Brush_2
  brush_2_mac: !secret brush_2_mac

esphome:
  # Basic ESPHome device metadata
  name: ${devicename}
  friendly_name: ${friendly_name}
  comment: "Philips Sonicare BLE"

esp32:
  # Hardware/platform configuration
  board: esp32-c6-devkitc-1
  flash_size: 4MB
  framework:
    type: esp-idf

logger:
  # Global logging level (set to DEBUG temporarily when troubleshooting)
  level: INFO

api:
  # Home Assistant API with encrypted connection (key in secrets.yaml)
  encryption:
    key: !secret encryption_key

ota:
  # OTA updates protected by a password stored in secrets.yaml
  - platform: esphome
    password: !secret ota_password


wifi:
  # Wi‑Fi network credentials (stored in secrets.yaml)
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Fallback Access Point if station mode fails (useful for initial setup)
  ap:
    ssid: "Sonicare Fallback Hotspot"
    password: !secret ssid_password

captive_portal:
  # Enables captive portal when in AP mode to simplify connecting to AP
  # (No extra options required here.)
  {}

web_server:
  # Lightweight web server for local status/debug pages (port 80)
  # Consider restricting access if your network exposes this device to untrusted hosts.
  port: 80

esp32_ble_tracker:
  # BLE scanner/tracker for ESP32
  # NOTE: this ESPHome version doesn't support top-level `filters:` for this component,
  # so we implement per-advertisement handling in on_ble_advertise.
  on_ble_advertise:
    - lambda: |-
        // Helper: format raw Bluetooth address bytes into uppercase colon-separated MAC
        auto mac_from_bytes = [&](const uint8_t *addr)->std::string {
          char buf[18];
          snprintf(buf, sizeof(buf), "%02X:%02X:%02X:%02X:%02X:%02X",
                   addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
          return std::string(buf);
        };

        // Obtain address bytes from the advertisement packet
        const uint8_t *addr = x.address();
        if (addr == nullptr) {
          // Defensive check: log and skip if address is unexpectedly null
          ESP_LOGV("ble_filter", "Advertise with null address");
          return;
        }
        std::string mac = mac_from_bytes(addr);

        // Compare the formatted MAC against the substitutions for target brushes.
        // Use the same case/format (uppercase with colons) in the substitutions.
        if (mac == std::string("${brush_1_mac}") || mac == std::string("${brush_2_mac}")) {
          // Target device seen: allow normal processing and optionally log at DEBUG level
          ESP_LOGD("ble_filter", "Seen target device: %s", mac.c_str());
        } else {
          // Non-target device: verbose log and return early to avoid extra work here.
          // Note this does not completely stop esp32_ble_tracker from receiving packets,
          // but prevents running package-specific logic for non-target devices.
          ESP_LOGV("ble_filter", "Ignoring device: %s", mac.c_str());
        }

# Local package usage:
# Each brush instance references the same local sonicare.yaml package file located in
# /config/esphome/packages/sonicare.yaml. Paths here are relative to /config/esphome.
packages:
  brush_1:
    url: https://github.com/KostuaD/Sonicare
    files:
      - path: packages/sonicare.yaml
        vars:
          mac: ${brush_1_mac}
          id: ${brush_1_name}
          name: ${brush_1_name}

  brush_2:
    url: https://github.com/KostuaD/Sonicare
    files:
      - path: packages/sonicare.yaml
        vars:
          mac: ${brush_2_mac}
          id: ${brush_2_name}
          name: ${brush_2_name}

button:
  - platform: restart
    # Diagnostic button to reboot the ESP device from Home Assistant UI
    icon: mdi:power-cycle
    name: ${entity_name} ESP Reboot
    entity_category: diagnostic

text_sensor:
  - platform: wifi_info
    # Publish current IP address as a text sensor (useful for debugging)
    ip_address:
      name: "IP Address"

  - platform: template
    # Human-readable uptime string published by the uptime sensor's on_raw_value handler
    name: "Uptime"
    id: uptime_${friendly_name}
    icon: mdi:clock-start

sensor:
  - platform: wifi_signal
    # Raw Wi‑Fi RSSI in dBm (diagnostic)
    name: "WiFi Signal dB"
    id: wifi_signal_db
    update_interval: 60s
    entity_category: diagnostic

  - platform: template
    # Convert dBm to a 0–100% signal strength for easier reading in UI
    name: "WiFi Signal Percent"
    id: wifi_signal_percent
    update_interval: 60s
    lambda: |-
      float db = id(wifi_signal_db).state;
      // Map [-100..-50] dBm into [0..100]%, clamp to [0,100]
      float pct = fmin(fmax(2.0 * (db + 100.0), 0.0), 100.0);
      return pct;
    unit_of_measurement: "%"
    icon: "mdi:wifi"
    entity_category: diagnostic

  - platform: uptime
    # Internal uptime sensor (seconds). This is marked internal and used to update
    # the human-readable template text_sensor above.
    name: "Uptime Sensor"
    id: uptime_sensor
    update_interval: 60s
    internal: true
    on_raw_value:
      then:
        - text_sensor.template.publish:
            id: uptime_${friendly_name}
            state: !lambda |-
              // Protect against invalid values (NaN or infinity)
              if (!std::isfinite(x)) return std::string("0s");
              int seconds = (int)round(x);
              int days = seconds / (24 * 3600);
              seconds = seconds % (24 * 3600);
              int hours = seconds / 3600;
              seconds = seconds % 3600;
              int minutes = seconds / 60;

              // Build a compact human-readable uptime string, e.g. "1d 2h 3m"
              std::string result = "";
              if (days) result += std::to_string(days) + "d ";
              if (hours) result += std::to_string(hours) + "h ";
              if (minutes || (!days && !hours)) result += std::to_string(minutes) + "m";

              return result;
